---
title: "Scrip 2_Cell.Type.Proportion.Estimation"
author: "Nickie Safarian"
date: "11/29/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

The aim is to perform cell-type deconvolution to estimate how proportions of cell-types in the brain change in response to various conditions. You can learn more about the Marker Gene Profiles tool by reading the documentation and by reading Mancarci et al. 2017 that describes it in greater detail.

We will use Marker Gene Profiles, a computational technique that attempts to decompose bulk tissue gene expression into a list of cell-types proportion estimates.

Cell-type deconvolution requires three components:

 1- A set of marker genes per cell type that you want to estimate. We will use
    the markers generated by Sonny Chen from human scRNA-seq data.

 2- Gene expression measured in bulk tissue samples. We’ll use the GTex data.      

 3- A scientific question: We’re investigating what 
    cell-types change in response to natural aging.


## Load packages

```{r, include=FALSE}

#BiocManager::install("edgeR")
library(edgeR)
#devtools::install_github('oganm/markerGeneProfile', force = T) # install marker gene profile tool from github
library(markerGeneProfile)
#install.packages("tidyverse")
library(tidyverse)
#install.packages("matrixStats")
library(matrixStats)
#install.packages("cowplot")
library(cowplot)
#install.packages("broom")
library(broom)
#install.packages("knitr")
library(knitr)
#install.packages("ggpubr")
library(ggpubr)
theme_set(theme_cowplot())

```

## Load data

```{r, echo=FALSE}

Metadata <- read.csv(file=
                       file.path("~/GTex_Data_Analysis/Data/getx_MetadataFull_ONLY.BA9.Samples.csv"))%>% 
  dplyr::select(SAMPID,
                SUBJID, 
                AGE,  
                SEX,
                RACE, 
                RIN= 'SMRIN', 
                PMI= 'TRISCHD') # grab specific columns and rename for clarity                                                                                                            
  
Counts <- readRDS(file=file.path( "~/GTex_Data_Analysis/Data/gtexV8_RNAseq.Reads_ONLY.BA9.Samples.Rds")) 
# a matrix of 56200 * 209

# only keep samples that have RNAseq data
Metadata <- Metadata %>% subset(SAMPID %in% colnames(Counts))

```


## Normalize and process
Because of possible differences in sequencing depth between different bulk brain gene expression samples, we will normalize for these differences using the Counts Per Million metric in the edgeR package.

```{r}

# normalize using CPM, add 0.1 to every observation, and log2 transform 
Counts_cpm = edgeR::cpm(Counts, log = TRUE, prior.count = 1)

# preview
kable(Counts_cpm[1:3, 1:4])


```

Find genes with low standard deviations and remove them from the expression matrix.

```{r}

# calculate standard deviation per row
gene_sds = rowSds(Counts_cpm, na.rm = T) 

# keep rows (genes) with sd greater than 0.1 across all samples 
gene_mat = Counts_cpm[gene_sds > .1, ] %>%
  as.data.frame() #49565 genes remains

```


```{r}
# DO NOT RUN THIS Chunk! 

# remove the extra characters from Ensembl IDs
gene_mat$ensemblID <- sapply(strsplit(rownames(gene_mat), split="\\." ), "[", 1 )

# add genes name column  
library(org.Hs.eg.db)
gene_mat$symbol <- mapIds(org.Hs.eg.db, 
                        keys=gene_mat$ensemblID, 
                        keytype= "ENSEMBL", 
                        column= "SYMBOL" )

#reorder and remove the ensemblID column
gene_mat <- gene_mat[, c(211,210, 1:209)] 
 
# filter duplicated genes
gene_mat <- gene_mat %>% filter(! is.na(symbol)) #30488 remains
                                
# you may remove duplicated genes too                                
gene_mat <- gene_mat %>% filter(duplicated(symbol) == FALSE) #30445 genes remain

# Important!
# first remove the rownames  
rownames(gene_mat) <- NULL

# then convert gene_symbol column to rownames
gene_mat <- gene_mat %>% column_to_rownames(var = "symbol") # NAs are not allowed, this returned error!!!! 

# remove the ensemleID column too
gene_mat <- gene_mat[ , -1] %>% as.data.frame() %>%
  rownames_to_column(var = "gene_symbol")

```


## Cell-proportion estimation

Import the marker gene list from Sony's Github page.


```{r}

# marker genes list (importing and processing)

markers_df <- read.csv(url('https://raw.githubusercontent.com/sonnyc247/MarkerSelection/master/Data/Outputs/CSVs_and_Tables/Markers/All_hodge_regions/new_ALLReg_results_SubclassWithExc.csv'))

cell_types = markers_df$subclass %>% unique()

marker_list = lapply(cell_types, function(cell_type){
  return(markers_df %>% filter(subclass == cell_type) %>% pull(gene) %>% unlist())
})

names(marker_list) = cell_types

print(cell_types) #13 subclass


```

## Run mgpEstimate to get cell type proportions for each bulk tissue sample

```{r}

# Run marker gene profile (MGP) analysis
estimations =  mgpEstimate(
  exprData = gene_mat,
  genes = marker_list,
  geneColName = 'gene_symbol',
  outlierSampleRemove = FALSE, # should outlier samples removed. This is done using boxplot stats
  geneTransform = NULL, # this is the default option for geneTransform
  groups = NULL, # if there are experimental groups provide them here. if not desired set to NULL
  seekConsensus = FALSE, # ensures gene rotations are positive in both of the groups
  removeMinority = TRUE)

# get proportion estimates as data frame
estimations_df = as.data.frame(estimations$estimates) %>%
  rownames_to_column(var = "ID")

# get proportion estimates as data frame
estimations_df = as.data.frame(estimations$estimates) %>%
  rownames_to_column(var = "ID")

# proportions are unit-less and negative numbers are just a result of PCA
# we can scale proportions between 0-1 for visualization purposes 
scale0 = function(x){
   (x-min(x))/(max(x)-min(x))
}
estimations_df_norm = scale0(estimations_df[,-1])
estimations_df_norm = estimations_df_norm %>%
  mutate(ID = estimations_df$ID) %>%
  dplyr::select(ID, everything())

# merge cell type proportions with sample metadata
mgp_df = left_join(Metadata, estimations_df_norm, by = c("SAMPID"="ID")) 

# pivot longer so there is one row per sample and cell type
# this type of data structure is preferred by ggplot
mgp_df.long <- mgp_df%>% pivot_longer(-colnames(Metadata),
               names_to = "cell_type",
               values_to = "cell_proportion")

# fix labels 
mgp_df.long$cell_type = gsub("\\.", "/", mgp_df.long$cell_type)

# preview 
kable(mgp_df.long[1:4, 1:5])

```


## Quality-control of cell-proportion estimates

Let’s take a look at some of the quality metrics we have available for MGP calculations when we use the mgpEstimate function.

We define our QC algorithm such that it returns a data frame with the cell type, markers_used (list of marker genes used per cell type), removed_marker_ratios (list of removed marker ratios per cell type), and percent_variance_PC1 (list of variance explained by the first PC per cell type).

```{r}

# loop through each cell type 
for(i in 1:length(cell_types)){
  # get the expression values of markers kept by mgpEstimate() per bulk sample 
  cells_df = estimations$usedMarkerExpression[i] %>% as.data.frame()
  # get list of markers kept by mgpEstimate()
  masterlist = paste0(rownames(cells_df), collapse=', ')
  # number of markers kept by mgpEstimate()
  num_markers = length(rownames(cells_df))
  # ratio of markers removed
  rm_marker_ratios = estimations$removedMarkerRatios[i]
  # check if the trimmed PCs are not(!) empty (NULL)
  if(!is.null(estimations$trimmedPCAs[[i]])){
    # get the percent variance that each principal component (PC) captures in the data 
    percent_variance = ((summary(estimations$trimmedPCAs[[i]]))[6]) %>% as.data.frame()
    # get the percent variance that the first principal component (PC1) captures in the data 
    percent_variance_PC1 = percent_variance[2,1]
  }
  else{
    # otherwise, the set this to NA
    percent_variance_PC1 = NA
  }
  # build a dataframe with all our metrics
  # initialize dataframe if this is the first iteration of the for() loop
  if(i==1){
    master_df = data.frame("markers_used" = masterlist, 
                           "removed_marker_ratios" = rm_marker_ratios,
                           "percent_variance_PC1" = percent_variance_PC1, 
                           "num_markers" = num_markers)  
  }
  # bind previous iterations results
  else{
    df = data.frame("markers_used" = masterlist, 
                    "removed_marker_ratios" = rm_marker_ratios,
                    "percent_variance_PC1" = percent_variance_PC1, 
                    "num_markers" = num_markers)
    master_df = rbind(master_df, df)
  }
}
QC_metrics = rownames_to_column(master_df, var = "celltype")

```


Let’s plot these QC metrics to get a better idea of what's going on in the mgpEstimate function.

```{r}

QC_metrics %>%  ggplot(aes(x = celltype, y = num_markers)) +
      theme_minimal() +
      geom_bar(stat = "identity", fill = "#e0abf5") +
      geom_hline(yintercept = 4) + 
      labs(title="Plot of Number of Markers Per Celltype", 
           x="Cell Type", y = "Markers Used")+
      theme(axis.text.x = element_text(angle = 45, vjust = 0.5)) +
      coord_flip()

```

We’ve drawn a line here where we consider there to be too few markers used to calculate the cell-type proportion estimate for it to be considered robust. Let’s look at another measure of the quality of the MGPs, the percent variance explained by PC (principal component) 1.

```{r}

QC_metrics %>%  ggplot(aes(x=celltype, y=percent_variance_PC1))+
  geom_bar(stat = "identity", fill =ifelse(QC_metrics$percent_variance_PC1 > 0.35, "#AFEEEE", "#808080")) +
  geom_hline(yintercept = 0.35) +
  labs(title="Percent Variance Explained by Each MGP",
        x="MGPs", y = "Percent Variance Explained by PC 1")+
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 90)) + coord_flip()

```


We consider more than 35% variance explained by PC1 (indicated by the horizontal line) to be a robust cell type proportion estimate. This means all the blue cell type proportion estimates (MGPs) are likely to be good surrogates for cell counts.

Now, let’s plot marker gene proportions (MGPs) vs. sample age.

```{r}

# create a vector of cell types to plot 
plot_genes = c("SST")
# create a list to store plots generated within the for loop
plot_list = list()

# loop through vector of genes to plot
for(i in 1:length(plot_genes)){
  plot_list[[i]] = ggplot(
    # subset by cell type 
    mgp_df.long %>% filter(cell_type == plot_genes[i]),
    aes(x = AGE, y = cell_proportion)) +
    geom_smooth(method = "lm", se = F) + 
    geom_point() +
    ggtitle(paste(plot_genes[i])) +
    ylab(paste(plot_genes[i], " MGP")) + xlab ("sample age (years)") +
    theme_bw() 
}
# bring plots together
plot_grid(plotlist = plot_list, nrow = 1)

```


## Linear models
We will use R’s linear modeling function lm to fit a statistical model against each cell type proportion and a number of covariates, including SEX, RIN (RNA integrity number), PMI (post mortem interval), AGE, and RACE.

The model form here is: cell_type_prop ~ age+sex

To fit many models with broom, it’s useful to use pivot_longer to stack the data into one column - then group_by() to “split” the stacked data.

```{r}

mgp_df.long$SEX[mgp_df.long$SEX=="1"] <- "male"
mgp_df.long$SEX[mgp_df.long$SEX=="2"] <- "female"

mgp_df.long$RACE[mgp_df.long$RACE=="2"] <- "2A"
mgp_df.long$RACE[mgp_df.long$RACE=="3"] <- "3B"


library(broom)
# Linear modeling
lm_df = mgp_df.long %>%
  # each step performed after this line is done with each cell type 
  group_by(cell_type) %>%
  # fit cell type proportions according to this model  
  # using the broom package to tidy the results 
  do(tidy(lm(scale(cell_proportion) ~ RACE+SEX+scale(PMI)+scale(RIN)+scale(AGE),  data = .))) %>%
  # ungroup the data
  ungroup() %>%
  # adjust for multiple comparisons using the Benjamini-Hochberg method
  mutate(padj = p.adjust(`p.value`, method = 'BH')) %>%
  # clean up variable names 
  mutate(term = recode(term, 
                       `(Intercept)` = "Intercept", 
                       `RACE3B` = "RACE",
                       `SEXmale` = "SEX",
                       `scale(AGE)` = "AGE",
                       `scale(PMI)` = "PMI",
                       `scale(RIN)` = "RIN"))
  


# print data frame for just age beta coefficients
kable(lm_df %>% filter(term == 'AGE'))

```



```{r}

# beta coeffs per cell type for phenotype 
beta_plot = lm_df %>% 
  filter(cell_type %in% c('SST'), ! term =="Intercept") %>% 
  mutate(cell_type = fct_reorder(cell_type, estimate)) %>% 
  ggplot(aes(x = term, y = estimate, fill= term)) + 
  geom_hline(yintercept = 0) + 
  geom_bar(stat = "identity") + 
  geom_errorbar(aes(ymin = estimate - std.error, ymax = estimate + std.error)) + 
  ggtitle("SST cell type proportion correlation with AGE") +
  ylab('Std. Beta coeff.') + 
  xlab('Cell type proportions') + 
  theme(axis.text.x = element_text(size=10, face='bold', 
                                   angle = 90, vjust = 0.5, hjust=1))+
  scale_fill_brewer(palette="PuBuGn", direction = -1)
  #facet_wrap(~term, drop = T, scale = "free")


beta_plot

```



```{r}

#save
saveRDS(Counts_cpm , 'GTeX_V8_Counts_cpm_ONLY209.BA9Samples.Rds')
saveRDS(gene_mat, 'GTeX_V8_Counts_cpm_with.sd.more.than0.1_ONLY209.BA9Samples.Rds')

write.csv(markers_df, "marker.genes.for.brain.cell.types.csv")
write.csv(mgp_df, "GTeX_V8_Metadata_with.Cell.type.Prop.estimates_209.BA9.Samples.csv")

```



